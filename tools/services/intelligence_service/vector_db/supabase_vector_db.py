#!/usr/bin/env python3
"""
Supabase Vector Database Implementation

PostgreSQL with pgvector extension implementation supporting:
- Vector similarity search using IVFFLAT index
- Full-text search using PostgreSQL's tsvector/tsquery
- Hybrid search with result fusion
- User isolation and metadata filtering
"""

from typing import List, Dict, Any, Optional
import logging
import json
from datetime import datetime

from .base_vector_db import BaseVectorDB, SearchResult, VectorSearchConfig, SearchMode
from core.database.supabase_client import get_supabase_client

logger = logging.getLogger(__name__)

class SupabaseVectorDB(BaseVectorDB):
    """
    Supabase implementation of vector database with hybrid search.
    
    Features:
    - pgvector for semantic similarity search
    - PostgreSQL full-text search for lexical search
    - Optimized queries with proper indexing
    - User isolation and access control
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize Supabase vector database.
        
        Args:
            config: Configuration including table_name, schema, etc.
        """
        super().__init__(config)
        
        self.supabase = get_supabase_client()
        self.table_name = self.config.get('table_name', 'user_knowledge')
        self.schema = self.config.get('schema', 'dev')
        self.vector_dimension = self.config.get('vector_dimension', 1536)
        self.distance_metric = self.config.get('distance_metric', 'cosine')
        
        # Full table name with schema
        self.full_table_name = f"{self.schema}.{self.table_name}"
        
        self.logger.info(f"Initialized SupabaseVectorDB with table: {self.full_table_name}")
    
    async def store_vector(
        self,
        id: str,
        text: str,
        embedding: List[float],
        user_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> bool:
        """
        Store a text with its embedding in Supabase.
        
        The text_search_vector will be automatically generated by the database trigger.
        """
        try:
            now = datetime.now().isoformat()
            
            # Prepare data for insertion
            vector_data = {
                'id': id,
                'user_id': user_id,
                'text': text,
                'embedding_vector': embedding,
                'metadata': metadata or {},
                'created_at': now,
                'updated_at': now
            }
            
            # Insert into database (trigger will handle text_search_vector)
            result = self.supabase.table(self.table_name).insert(vector_data).execute()
            
            if result.data:
                self.logger.debug(f"Stored vector {id} for user {user_id}")
                return True
            else:
                self.logger.error(f"Failed to store vector {id}: {result}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error storing vector {id}: {e}")
            return False
    
    async def search_vectors(
        self,
        query_embedding: List[float],
        user_id: str,
        config: VectorSearchConfig
    ) -> List[SearchResult]:
        """
        Search vectors using semantic similarity (pgvector).
        
        Uses the database function for efficient cosine similarity search with IVFFLAT index.
        """
        try:
            # Use the database function for vector search
            result = self.supabase.rpc(
                'search_user_knowledge_vector',
                {
                    'p_user_id': user_id,
                    'p_embedding': query_embedding,
                    'p_limit': config.top_k
                }
            ).execute()
            
            if not result.data:
                return []
            
            # Convert to SearchResult objects
            search_results = []
            for row in result.data:
                search_result = SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=float(row['similarity_score']) if row['similarity_score'] else 0.0,
                    semantic_score=float(row['similarity_score']) if row['similarity_score'] else 0.0,
                    metadata=row.get('metadata', {}),
                    embedding=row.get('embedding_vector') if config.include_embeddings else None
                )
                search_results.append(search_result)
            
            return search_results
            
        except Exception as e:
            self.logger.error(f"Vector search failed for user {user_id}: {e}")
            # Fallback to manual calculation if database function fails
            return await self._fallback_vector_search(query_embedding, user_id, config)
    
    async def search_text(
        self,
        query_text: str,
        user_id: str,
        config: VectorSearchConfig
    ) -> List[SearchResult]:
        """
        Search text using PostgreSQL full-text search (tsvector/tsquery).
        
        Uses the database function with GIN index on text_search_vector for efficient BM25-style search.
        """
        try:
            # Use the database function for text search
            result = self.supabase.rpc(
                'search_user_knowledge_text',
                {
                    'p_user_id': user_id,
                    'p_query': query_text,
                    'p_limit': config.top_k
                }
            ).execute()
            
            if not result.data:
                return []
            
            # Convert to SearchResult objects
            search_results = []
            for row in result.data:
                search_result = SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=float(row['rank_score']) if row['rank_score'] else 0.0,
                    lexical_score=float(row['rank_score']) if row['rank_score'] else 0.0,
                    metadata=row.get('metadata', {}),
                    embedding=None  # Text search doesn't return embeddings by default
                )
                search_results.append(search_result)
            
            return search_results
            
        except Exception as e:
            self.logger.error(f"Text search failed for user {user_id}: {e}")
            # Fallback to simple ILIKE search if full-text search fails
            return await self._fallback_text_search(query_text, user_id, config)
    
    async def hybrid_search(
        self,
        query_text: str,
        query_embedding: List[float],
        user_id: str,
        config: VectorSearchConfig
    ) -> List[SearchResult]:
        """
        Perform hybrid search using the database function for optimal performance.
        
        Uses the native database function that combines full-text and vector search.
        """
        try:
            # Use the database function for hybrid search
            result = self.supabase.rpc(
                'search_user_knowledge_hybrid',
                {
                    'p_user_id': user_id,
                    'p_query': query_text,
                    'p_embedding': query_embedding,
                    'p_text_weight': config.lexical_weight,
                    'p_vector_weight': config.semantic_weight,
                    'p_limit': config.top_k
                }
            ).execute()
            
            if not result.data:
                return []
            
            # Convert to SearchResult objects
            search_results = []
            for row in result.data:
                search_result = SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=float(row['combined_score']) if row['combined_score'] else 0.0,
                    semantic_score=float(row['vector_score']) if row['vector_score'] else 0.0,
                    lexical_score=float(row['text_score']) if row['text_score'] else 0.0,
                    metadata=row.get('metadata', {}),
                    embedding=row.get('embedding_vector') if config.include_embeddings else None
                )
                search_results.append(search_result)
            
            self.logger.debug(f"Native hybrid search returned {len(search_results)} results")
            return search_results
            
        except Exception as e:
            self.logger.warning(f"Native hybrid search failed: {e}, falling back to parent implementation")
            # Fallback to the parent class implementation
            return await super().hybrid_search(query_text, query_embedding, user_id, config)
    
    async def _fallback_text_search(
        self,
        query_text: str,
        user_id: str,
        config: VectorSearchConfig
    ) -> List[SearchResult]:
        """
        Fallback text search using ILIKE when full-text search fails.
        """
        try:
            # Simple substring search as fallback
            query = self.supabase.table(self.table_name)\
                .select('id, text, metadata, created_at')\
                .eq('user_id', user_id)\
                .ilike('text', f'%{query_text}%')\
                .limit(config.top_k)
            
            result = query.execute()
            
            if not result.data:
                return []
            
            # Convert to SearchResult objects with basic scoring
            search_results = []
            for i, row in enumerate(result.data):
                # Simple relevance score based on position
                score = 1.0 / (i + 1)
                
                search_result = SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=score,
                    lexical_score=score,
                    metadata=row.get('metadata', {})
                )
                search_results.append(search_result)
            
            return search_results
            
        except Exception as e:
            self.logger.error(f"Fallback text search failed: {e}")
            return []
    
    async def delete_vector(self, id: str, user_id: str) -> bool:
        """Delete a vector by ID with user access control."""
        try:
            result = self.supabase.table(self.table_name)\
                .delete()\
                .eq('id', id)\
                .eq('user_id', user_id)\
                .execute()
            
            success = bool(result.data)
            if success:
                self.logger.debug(f"Deleted vector {id} for user {user_id}")
            else:
                self.logger.warning(f"Vector {id} not found for user {user_id}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"Error deleting vector {id}: {e}")
            return False
    
    async def get_vector(self, id: str, user_id: str) -> Optional[SearchResult]:
        """Get a specific vector by ID with user access control."""
        try:
            result = self.supabase.table(self.table_name)\
                .select('id, text, metadata, created_at, embedding_vector')\
                .eq('id', id)\
                .eq('user_id', user_id)\
                .single()\
                .execute()
            
            if result.data:
                row = result.data
                return SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=1.0,  # Default score for direct retrieval
                    metadata=row.get('metadata', {}),
                    embedding=row.get('embedding_vector')
                )
            else:
                return None
                
        except Exception as e:
            self.logger.error(f"Error getting vector {id}: {e}")
            return None
    
    async def list_vectors(
        self,
        user_id: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[SearchResult]:
        """List vectors for a user with pagination."""
        try:
            result = self.supabase.table(self.table_name)\
                .select('id, text, metadata, created_at')\
                .eq('user_id', user_id)\
                .order('created_at', desc=True)\
                .limit(limit)\
                .offset(offset)\
                .execute()
            
            search_results = []
            for row in result.data or []:
                search_result = SearchResult(
                    id=row['id'],
                    text=row['text'],
                    score=1.0,  # Default score for listing
                    metadata=row.get('metadata', {})
                )
                search_results.append(search_result)
            
            return search_results
            
        except Exception as e:
            self.logger.error(f"Error listing vectors for user {user_id}: {e}")
            return []
    
    async def get_stats(self, user_id: Optional[str] = None) -> Dict[str, Any]:
        """Get database statistics."""
        try:
            stats = {}
            
            # Build base query
            query = self.supabase.table(self.table_name).select('id', count='exact')
            
            if user_id:
                query = query.eq('user_id', user_id)
                stats['user_id'] = user_id
            
            # Get total count
            result = query.execute()
            stats['total_vectors'] = result.count or 0
            
            # Get additional statistics if needed
            if user_id:
                # User-specific stats
                metadata_query = self.supabase.table(self.table_name)\
                    .select('metadata, created_at')\
                    .eq('user_id', user_id)\
                    .execute()
                
                if metadata_query.data:
                    stats['avg_text_length'] = 0  # Would need to calculate from actual data
                    stats['creation_dates'] = [row['created_at'] for row in metadata_query.data]
            
            stats['database_type'] = 'supabase'
            stats['table_name'] = self.full_table_name
            stats['vector_dimension'] = self.vector_dimension
            
            return stats
            
        except Exception as e:
            self.logger.error(f"Error getting stats: {e}")
            return {'error': str(e), 'database_type': 'supabase'}
    
    def _cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """
        Calculate cosine similarity between two vectors.
        
        This is a fallback implementation. In production, we should use
        the database's vector operations for better performance.
        """
        try:
            import math
            
            if len(vec1) != len(vec2):
                return 0.0
            
            dot_product = sum(a * b for a, b in zip(vec1, vec2))
            magnitude1 = math.sqrt(sum(a * a for a in vec1))
            magnitude2 = math.sqrt(sum(a * a for a in vec2))
            
            if magnitude1 == 0.0 or magnitude2 == 0.0:
                return 0.0
            
            return dot_product / (magnitude1 * magnitude2)
            
        except Exception:
            return 0.0
    
    async def _fallback_vector_search(
        self,
        query_embedding: List[float],
        user_id: str,
        config: VectorSearchConfig
    ) -> List[SearchResult]:
        """
        Fallback vector search using manual cosine similarity calculation.
        """
        try:
            # Get all vectors for the user
            query = self.supabase.table(self.table_name)\
                .select('id, text, metadata, created_at, embedding_vector')\
                .eq('user_id', user_id)\
                .limit(1000)  # Reasonable limit for manual processing
            
            result = query.execute()
            
            if not result.data:
                return []
            
            # Calculate cosine similarities manually
            search_results = []
            for row in result.data:
                if row.get('embedding_vector'):
                    similarity = self._cosine_similarity(query_embedding, row['embedding_vector'])
                    
                    search_result = SearchResult(
                        id=row['id'],
                        text=row['text'],
                        score=similarity,
                        semantic_score=similarity,
                        metadata=row.get('metadata', {}),
                        embedding=row['embedding_vector'] if config.include_embeddings else None
                    )
                    search_results.append(search_result)
            
            # Sort by similarity score descending and return top_k
            search_results.sort(key=lambda x: x.score, reverse=True)
            return search_results[:config.top_k]
            
        except Exception as e:
            self.logger.error(f"Fallback vector search failed: {e}")
            return []